# Конструкторы экземпляров и классы \(ссылочные типы\)

Конструкторы — это специальные методы, позволяющие корректно инициализировать новый экземпляр типа. В таблице определений, входящих в метаданные, методы-конструкторы всегда отмечают сочетанием .ctor \(от constructor\). При создании экземпляра объекта ссылочного типа выделяется память для полей данных экземпляра и инициализируются служебные поля \(указатель на объект-тип и индекс блока синхронизации\), после чего вызывается конструктор экземпляра, устанавливающий исходное состояние нового объекта.

Конструкторы в отличие от других методов не наследуются из базового класса.

Для абстрактных классов компилятор создает конструктор по умолчанию с модификатором protected, в противном случае область действия будет открытой \(public\).

Конструкторов может быть несколько. В случае, если мы внутри нашего типа определяем какие-то поля примитивного или любого другого типа и сразу же в коде инициализируем значение, то IL-код этих полей будет выполняться в начале каждого метода-конструктора.

```
internal sealed class SomeType {
private Int32 m_x = 5;
private String m_s = "Hi there";
private Double m_d = 3.14159;
private Byte m_b;

// Это конструкторы
public SomeType()         { ... }
public SomeType(Int32 x)  { ... }
public SomeType(String s) { ...; m_d = 10; } }
```

# Конструкторы экземпляров и структуры \(значимые типы\)

Конструкторы значимых типов \(struct\) работают иначе, чем ссылочных \(class\). CLR всегда разрешает создание экземпляров значимых типов и этому ничто не может помешать. Поэтому, по большому счету, конструкторы у значимого типа можно не определять. Фактически многие компиляторы \(включая C\#\) не определяют для значимых типов конструкторы по умолчанию, не имеющие параметров.

---
# Конструкторы типов

Помимо конструкторов экземпляров, CLR поддерживает конструкторы типов (также известные как статические конструкторы, конструкторы классов и инициализаторы типов). Конструкторы типов можно применять и к интерфейсам (хотя C# этого не допускает), ссылочным и значимым типам. Подобно тому, как конструкторы экземпляров используются для установки первоначального состояния экземпляра типа, конструкторы типов служат для установки первоначального состояния типа. По умолчанию у типа не определено конструктора. У типа не может быть более одного конструктора; кроме того, у конструкторов типов никогда не бывает параметров. Вот как определяются ссылочные и значимые типы с конструкторами в программах на C#:

internal sealed class SomeRefType {  
    static SomeRefType() {
    // Исполняется при первом обращении к ссылочному типу SomeRefType
   }
}

internal struct SomeValType {   
// C# на самом деле допускает определять для значимых типов   
// конструкторы без параметров
   static SomeValType() {
       // Исполняется при первом обращении к значимому типу SomeValType
   }
} 

В статических конструктора нельзя использовать модификаторы доступа!!! Компилятор автоматически помечает их как private!





